From f59194b90aedf7100e0351e644d6f1b9c53495d8 Mon Sep 17 00:00:00 2001
From: beck <>
Date: Tue, 3 Jan 2017 05:34:48 +0000
Subject: [PATCH] bring in boring's internal check_trust function to fix a bug
 introduced when we went to alternate cert chains. this correctly does not
 clobber the ctx->error when using an alt chain. ok jsing@

---
 crypto/x509/x509_vfy.c | 103 +++++++++++++++++++++++++++++---------
 1 file changed, 79 insertions(+), 24 deletions(-)

diff --git a/crypto/x509/x509_vfy.c b/crypto/x509/x509_vfy.c
index 7f888fc..c8f5498 100644
--- a/crypto/x509/x509_vfy.c
+++ b/crypto/x509/x509_vfy.c
@@ -775,32 +775,87 @@ check_name_constraints(X509_STORE_CTX *ctx)
 	return 1;
 }
 
-static int
-check_trust(X509_STORE_CTX *ctx)
+/* Given a certificate try and find an exact match in the store */
+
+static X509 *lookup_cert_match(X509_STORE_CTX *ctx, X509 *x)
 {
-#ifdef OPENSSL_NO_CHAIN_VERIFY
-	return 1;
-#else
-	int i, ok;
-	X509 *x;
-	int (*cb)(int xok, X509_STORE_CTX *xctx);
+	STACK_OF(X509) *certs;
+	X509 *xtmp = NULL;
+	size_t i;
 
-	cb = ctx->verify_cb;
-	/* For now just check the last certificate in the chain */
-	i = sk_X509_num(ctx->chain) - 1;
-	x = sk_X509_value(ctx->chain, i);
-	ok = X509_check_trust(x, ctx->param->trust, 0);
-	if (ok == X509_TRUST_TRUSTED)
-		return 1;
-	ctx->error_depth = i;
-	ctx->current_cert = x;
-	if (ok == X509_TRUST_REJECTED)
-		ctx->error = X509_V_ERR_CERT_REJECTED;
+	/* Lookup all certs with matching subject name */
+	certs = ctx->lookup_certs(ctx, X509_get_subject_name(x));
+	if (certs == NULL)
+		return NULL;
+
+	/* Look for exact match */
+	for (i = 0; i < sk_X509_num(certs); i++) {
+		xtmp = sk_X509_value(certs, i);
+		if (!X509_cmp(xtmp, x))
+			break;
+	}
+
+	if (i < sk_X509_num(certs))
+		X509_up_ref(xtmp);
 	else
-		ctx->error = X509_V_ERR_CERT_UNTRUSTED;
-	ok = cb(0, ctx);
-	return ok;
-#endif
+		xtmp = NULL;
+
+	sk_X509_pop_free(certs, X509_free);
+	return xtmp;
+}
+
+static int check_trust(X509_STORE_CTX *ctx)
+{
+	size_t i;
+	int ok;
+	X509 *x = NULL;
+	int (*cb) (int xok, X509_STORE_CTX *xctx);
+
+	cb = ctx->verify_cb;
+	/* Check all trusted certificates in chain */
+	for (i = ctx->last_untrusted; i < sk_X509_num(ctx->chain); i++) {
+		x = sk_X509_value(ctx->chain, i);
+		ok = X509_check_trust(x, ctx->param->trust, 0);
+
+		/* If explicitly trusted return trusted */
+		if (ok == X509_TRUST_TRUSTED)
+			return X509_TRUST_TRUSTED;
+		/*
+		 * If explicitly rejected notify callback and reject if not
+		 * overridden.
+		 */
+		if (ok == X509_TRUST_REJECTED) {
+			ctx->error_depth = i;
+			ctx->current_cert = x;
+			ctx->error = X509_V_ERR_CERT_REJECTED;
+			ok = cb(0, ctx);
+			if (!ok)
+				return X509_TRUST_REJECTED;
+		}
+	}
+	/*
+	 * If we accept partial chains and have at least one trusted certificate
+	 * return success.
+	 */
+	if (ctx->param->flags & X509_V_FLAG_PARTIAL_CHAIN) {
+		X509 *mx;
+		if (ctx->last_untrusted < (int)sk_X509_num(ctx->chain))
+			return X509_TRUST_TRUSTED;
+		x = sk_X509_value(ctx->chain, 0);
+		mx = lookup_cert_match(ctx, x);
+		if (mx) {
+			(void)sk_X509_set(ctx->chain, 0, mx);
+			X509_free(x);
+			ctx->last_untrusted = 0;
+			return X509_TRUST_TRUSTED;
+		}
+	}
+
+	/*
+	 * If no trusted certs in chain at all return untrusted and allow
+	 * standard (no issuer cert) etc errors to be indicated.
+	 */
+	return X509_TRUST_UNTRUSTED;
 }
 
 static int
