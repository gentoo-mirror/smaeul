From d19da376d2b75be30f5d4a8b11bcbefbd02ee74b Mon Sep 17 00:00:00 2001
From: Samuel Holland <samuel@sholland.org>
Date: Sat, 2 Sep 2017 13:41:00 -0500
Subject: [PATCH 04/21] Copy musl startup objects before building std

They are required for linking it, even though it is a library, because
crtn.o in post_link_objects, as hardcoded in src/librustc_back/target/
linux_musl_base.rs, is added to the linker command line for both
executables and libraries.
---
 src/bootstrap/compile.rs | 26 ++++++++++++++------------
 1 file changed, 14 insertions(+), 12 deletions(-)

diff --git a/src/bootstrap/compile.rs b/src/bootstrap/compile.rs
index f943499674..f83b1da7ab 100644
--- a/src/bootstrap/compile.rs
+++ b/src/bootstrap/compile.rs
@@ -85,6 +85,8 @@ pub fn std(build: &Build, target: &str, compiler: &Compiler) {
     if target.contains("musl") {
         if let Some(p) = build.musl_root(target) {
             cargo.env("MUSL_ROOT", p);
+            let libdir = build.sysroot_libdir(compiler, target);
+            copy_musl_third_party_objects(build, target, &libdir);
         }
     }
 
@@ -93,6 +95,18 @@ pub fn std(build: &Build, target: &str, compiler: &Compiler) {
               &libstd_stamp(build, &compiler, target));
 }
 
+/// Copies the crt(1,i,n).o startup objects
+///
+/// Since musl supports fully static linking, we can cross link for it even
+/// with a glibc-targeting toolchain, given we have the appropriate startup
+/// files. As those shipped with glibc won't work, copy the ones provided by
+/// musl so we have them on linux-gnu hosts.
+fn copy_musl_third_party_objects(build: &Build, target: &str, into: &Path) {
+    for &obj in &["crt1.o", "crti.o", "crtn.o"] {
+        copy(&build.musl_root(target).unwrap().join("lib").join(obj), &into.join(obj));
+    }
+}
+
 /// Link all libstd rlibs/dylibs into the sysroot location.
 ///
 /// Links those artifacts generated by `compiler` to a the `stage` compiler's
@@ -126,18 +140,6 @@ pub fn std_link(build: &Build,
     }
 }
 
-/// Copies the crt(1,i,n).o startup objects
-///
-/// Since musl supports fully static linking, we can cross link for it even
-/// with a glibc-targeting toolchain, given we have the appropriate startup
-/// files. As those shipped with glibc won't work, copy the ones provided by
-/// musl so we have them on linux-gnu hosts.
-fn copy_musl_third_party_objects(build: &Build, target: &str, into: &Path) {
-    for &obj in &["crt1.o", "crti.o", "crtn.o"] {
-        copy(&build.musl_root(target).unwrap().join("lib").join(obj), &into.join(obj));
-    }
-}
-
 fn copy_apple_sanitizer_dylibs(native_dir: &Path, platform: &str, into: &Path) {
     for &sanitizer in &["asan", "tsan"] {
         let filename = format!("libclang_rt.{}_{}_dynamic.dylib", sanitizer, platform);
-- 
2.13.5

